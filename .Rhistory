} else {
# Fixed effect
term_vars <- sapply(colnames(data), function(x) grepl(model_terms[i], x)) ## Change how this gets processed
term_var <- term_vars[term_vars == TRUE][1]
term_name <- names(term_var)
print(term_name)
# If it's a factor, create a column for each level.
if (is.factor(data[, term_name])) {
var_group <- paste0("fixed_", term_name)
lpar[[var_group]] <- c()
term_levels <- levels(data[, term_name])
for (term_level in term_levels) {
new_term_name <-  paste0("fixed_", term_name, term_level)
X[, new_term_name] <- 1 * (data[, term_name] == term_level)
lpar[[var_group]][[new_term_name]] <- 0
}
} else {
# Otherwise, create a single column:
new_term_name <- paste0(c("fixed_", term_name), collapse="")
X[, new_term_name] <- data[, term_name]
lpar[[new_term_name]] <- 0
}
}
}
}
lpar$hyper <- hyper
return(list(lpar=lpar, X=as.matrix(X[, -1]), Z=as.matrix(Z[, -1])))
}
build_design_matrix(dyad(node_1, node_2) ~ 0 + dyad_type + (1 | relatedness), df_reg)
build_design_matrix(dyad(node_1, node_2) ~ 0 + dyad_type + (1 | relatedness), df_reg)
build_design_matrix(dyad(node_1, node_2) ~ 0 + dyad_type + (1|relatedness), df_reg)
build_design_matrix(dyad(node_1, node_2) ~ 0 + dyad_type + relatedness, df_reg)
build_design_matrix <- function(formula, data) {
# Builds two design matrices for fixed and random effects.
# Also builds a group vector for the random effects.
# Don't forget intercept.
X <- data.frame(empty_col = rep(0, nrow(data)))
Z <- data.frame(empty_col = rep(0, nrow(data)))
lpar <- list()
hyper <- c() # Vector of hyperparameters.
# If there is an intercept
if (attr(terms(formula), "intercept") == 1) {
lpar$intercept = 0
X[, "intercept"] <- 1
}
#
model_terms <- labels(terms(formula))
# print(model_terms)
if (length(model_terms) > 0) {
for (i in 1:length(model_terms)) {
if (any(grep("dyad\\(.*,.*\\)", model_terms[i]))) {
# Node multimembership effect
var_group <- "node"
lpar[[var_group]] <- c()
# Get ID names in a different way. Can't rely on them being first in model terms.
id_vars <- sapply(colnames(data), function(x) grepl(x, model_terms[i]))
id_names <- names(id_vars[id_vars == TRUE])
term_levels <- levels(as.factor(unique(c(data[, id_names[1]], data[, id_names[2]]))))
for (term_level in term_levels) {
new_term_name <-  paste0("node_", term_level)
Z[, new_term_name] <- 1 * (as.factor(data[, id_names[1]]) == term_level)
Z[, new_term_name] <- Z[, new_term_name] + 1 * (as.factor(data[, id_names[2]]) == term_level)
lpar[[var_group]][[new_term_name]] <- 0
hyper[paste0(var_group, "_mu")] <- 0
hyper[paste0(var_group, "_sigma")] <- 0 # Will get exp.
}
} else if (any(grep("\\(.*1.*\\|.*\\)", model_terms[i]))) {
# Random effect
# Extract term name
term_vars <- sapply(colnames(data), function(x) grepl(x, model_terms[i]))
term_var <- term_vars[term_vars == TRUE][1]
term_name <- names(term_var)
print(paste("Random", term_name))
# Create variable grouping
var_group <- paste0("random_", term_name)
lpar[[var_group]] <- c()
term_levels <- levels(as.factor(data[, term_name]))
for (term_level in term_levels) {
new_term_name <-  paste0("random_", term_name, term_level)
Z[, new_term_name] <- 1 * (as.factor(data[, term_name]) == term_level)
lpar[[var_group]][[new_term_name]] <- 0
hyper[paste0(var_group, "_mu")] <- 0
hyper[paste0(var_group, "_sigma")] <- 0 # Will get exp.
}
} else {
# Fixed effect
term_vars <- sapply(colnames(data), function(x) grepl(model_terms[i], x)) ## Change how this gets processed
term_var <- term_vars[term_vars == TRUE][1]
term_name <- names(term_var)
print(paste("Fixed", term_name))
# If it's a factor, create a column for each level.
if (is.factor(data[, term_name])) {
var_group <- paste0("fixed_", term_name)
lpar[[var_group]] <- c()
term_levels <- levels(data[, term_name])
for (term_level in term_levels) {
new_term_name <-  paste0("fixed_", term_name, term_level)
X[, new_term_name] <- 1 * (data[, term_name] == term_level)
lpar[[var_group]][[new_term_name]] <- 0
}
} else {
# Otherwise, create a single column:
new_term_name <- paste0(c("fixed_", term_name), collapse="")
X[, new_term_name] <- data[, term_name]
lpar[[new_term_name]] <- 0
}
}
}
}
lpar$hyper <- hyper
return(list(lpar=lpar, X=as.matrix(X[, -1]), Z=as.matrix(Z[, -1])))
}
build_design_matrix(dyad(node_1, node_2) ~ 0 + dyad_type + (1|relatedness), df_reg)
build_design_matrix(dyad(node_1, node_2) ~ 0 + dyad_type + (1 | relatedness), df_reg)
build_design_matrix <- function(formula, data) {
# Builds two design matrices for fixed and random effects.
# Also builds a group vector for the random effects.
# Don't forget intercept.
X <- data.frame(empty_col = rep(0, nrow(data)))
Z <- data.frame(empty_col = rep(0, nrow(data)))
lpar <- list()
hyper <- c() # Vector of hyperparameters.
# If there is an intercept
if (attr(terms(formula), "intercept") == 1) {
lpar$intercept = 0
X[, "intercept"] <- 1
}
#
model_terms <- labels(terms(formula))
# print(model_terms)
if (length(model_terms) > 0) {
for (i in 1:length(model_terms)) {
print(paste("Model term: ", model_terms[i]))
if (any(grep("dyad\\(.*,.*\\)", model_terms[i]))) {
# Node multimembership effect
var_group <- "node"
lpar[[var_group]] <- c()
# Get ID names in a different way. Can't rely on them being first in model terms.
id_vars <- sapply(colnames(data), function(x) grepl(x, model_terms[i]))
id_names <- names(id_vars[id_vars == TRUE])
term_levels <- levels(as.factor(unique(c(data[, id_names[1]], data[, id_names[2]]))))
for (term_level in term_levels) {
new_term_name <-  paste0("node_", term_level)
Z[, new_term_name] <- 1 * (as.factor(data[, id_names[1]]) == term_level)
Z[, new_term_name] <- Z[, new_term_name] + 1 * (as.factor(data[, id_names[2]]) == term_level)
lpar[[var_group]][[new_term_name]] <- 0
hyper[paste0(var_group, "_mu")] <- 0
hyper[paste0(var_group, "_sigma")] <- 0 # Will get exp.
}
} else if (any(grep("\\(.*1.*\\|.*\\)", model_terms[i]))) {
# Random effect
# Extract term name
term_vars <- sapply(colnames(data), function(x) grepl(x, model_terms[i]))
term_var <- term_vars[term_vars == TRUE][1]
term_name <- names(term_var)
print(paste("Random", term_name))
# Create variable grouping
var_group <- paste0("random_", term_name)
lpar[[var_group]] <- c()
term_levels <- levels(as.factor(data[, term_name]))
for (term_level in term_levels) {
new_term_name <-  paste0("random_", term_name, term_level)
Z[, new_term_name] <- 1 * (as.factor(data[, term_name]) == term_level)
lpar[[var_group]][[new_term_name]] <- 0
hyper[paste0(var_group, "_mu")] <- 0
hyper[paste0(var_group, "_sigma")] <- 0 # Will get exp.
}
} else {
# Fixed effect
term_vars <- sapply(colnames(data), function(x) grepl(model_terms[i], x)) ## Change how this gets processed
term_var <- term_vars[term_vars == TRUE][1]
term_name <- names(term_var)
print(paste("Fixed", term_name))
# If it's a factor, create a column for each level.
if (is.factor(data[, term_name])) {
var_group <- paste0("fixed_", term_name)
lpar[[var_group]] <- c()
term_levels <- levels(data[, term_name])
for (term_level in term_levels) {
new_term_name <-  paste0("fixed_", term_name, term_level)
X[, new_term_name] <- 1 * (data[, term_name] == term_level)
lpar[[var_group]][[new_term_name]] <- 0
}
} else {
# Otherwise, create a single column:
new_term_name <- paste0(c("fixed_", term_name), collapse="")
X[, new_term_name] <- data[, term_name]
lpar[[new_term_name]] <- 0
}
}
}
}
lpar$hyper <- hyper
return(list(lpar=lpar, X=as.matrix(X[, -1]), Z=as.matrix(Z[, -1])))
}
build_design_matrix(dyad(node_1, node_2) ~ 0 + dyad_type + (1 | relatedness), df_reg)
any(grep("(\\.*1.*\\|.*\\)", model_terms[i]))
any(grep("(\\.*1.*\\|.*\\)", "1 | relatedness"))
any(grep("dyad\\(.*,.*\\)", "1 | relatedness"))
any(grep("dyad\\(1 .*|.*\\)", "1 | relatedness"))
any(grep("\\(1 .*|.*\\)", "1 | relatedness"))
any(grep("\\1 .*|.*\\", "1 | relatedness"))
any(grep("1 .*|.*", "1 | relatedness"))
any(grep("1 .*|.*", "0 | relatedness"))
any(grep("1.*|.*", "0 | relatedness"))
any(grep("1.*|.*", "relatedness"))
any(grep("\\1.*|.*", "relatedness"))
any(grep("1.*|.*", "relatedness"))
any(grep("1|.*", "relatedness"))
any(grep("1 |.*", "relatedness"))
any(grep("1 \\|.*", "relatedness"))
any(grep("1 \\|.*", "| relatedness"))
any(grep("1 \\|.*", "1| relatedness"))
any(grep("1 \\|.*", "1 | relatedness"))
any(grep("1 \s* \\|.*", "1 | relatedness"))
any(grep("1 \\s* \\|.*", "1 | relatedness"))
any(grep("1\\s*\\|.*", "1 | relatedness"))
any(grep("1\\s*\\|.*", "1| relatedness"))
any(grep("1\\s*\\|.*", "0| relatedness"))
any(grep("1\\s*\\|.*", "1| relatedness"))
any(grep("1\\s*\\|.*", "1|relatedness"))
any(grep("\\|", "1|relatedness"))
any(grep("\\|", "1relatedness"))
build_design_matrix <- function(formula, data) {
# Builds two design matrices for fixed and random effects.
# Also builds a group vector for the random effects.
# Don't forget intercept.
X <- data.frame(empty_col = rep(0, nrow(data)))
Z <- data.frame(empty_col = rep(0, nrow(data)))
lpar <- list()
hyper <- c() # Vector of hyperparameters.
# If there is an intercept
if (attr(terms(formula), "intercept") == 1) {
lpar$intercept = 0
X[, "intercept"] <- 1
}
#
model_terms <- labels(terms(formula))
# print(model_terms)
if (length(model_terms) > 0) {
for (i in 1:length(model_terms)) {
print(paste("Model term: ", model_terms[i]))
if (any(grep("dyad\\(.*,.*\\)", model_terms[i]))) {
# Node multimembership effect
var_group <- "node"
lpar[[var_group]] <- c()
# Get ID names in a different way. Can't rely on them being first in model terms.
id_vars <- sapply(colnames(data), function(x) grepl(x, model_terms[i]))
id_names <- names(id_vars[id_vars == TRUE])
term_levels <- levels(as.factor(unique(c(data[, id_names[1]], data[, id_names[2]]))))
for (term_level in term_levels) {
new_term_name <-  paste0("node_", term_level)
Z[, new_term_name] <- 1 * (as.factor(data[, id_names[1]]) == term_level)
Z[, new_term_name] <- Z[, new_term_name] + 1 * (as.factor(data[, id_names[2]]) == term_level)
lpar[[var_group]][[new_term_name]] <- 0
hyper[paste0(var_group, "_mu")] <- 0
hyper[paste0(var_group, "_sigma")] <- 0 # Will get exp.
}
} else if (any(grep("\\l", model_terms[i]))) {
# Random effect
# Extract term name
term_vars <- sapply(colnames(data), function(x) grepl(x, model_terms[i]))
term_var <- term_vars[term_vars == TRUE][1]
term_name <- names(term_var)
print(paste("Random", term_name))
# Create variable grouping
var_group <- paste0("random_", term_name)
lpar[[var_group]] <- c()
term_levels <- levels(as.factor(data[, term_name]))
for (term_level in term_levels) {
new_term_name <-  paste0("random_", term_name, term_level)
Z[, new_term_name] <- 1 * (as.factor(data[, term_name]) == term_level)
lpar[[var_group]][[new_term_name]] <- 0
hyper[paste0(var_group, "_mu")] <- 0
hyper[paste0(var_group, "_sigma")] <- 0 # Will get exp.
}
} else {
# Fixed effect
term_vars <- sapply(colnames(data), function(x) grepl(model_terms[i], x)) ## Change how this gets processed
term_var <- term_vars[term_vars == TRUE][1]
term_name <- names(term_var)
print(paste("Fixed", term_name))
# If it's a factor, create a column for each level.
if (is.factor(data[, term_name])) {
var_group <- paste0("fixed_", term_name)
lpar[[var_group]] <- c()
term_levels <- levels(data[, term_name])
for (term_level in term_levels) {
new_term_name <-  paste0("fixed_", term_name, term_level)
X[, new_term_name] <- 1 * (data[, term_name] == term_level)
lpar[[var_group]][[new_term_name]] <- 0
}
} else {
# Otherwise, create a single column:
new_term_name <- paste0(c("fixed_", term_name), collapse="")
X[, new_term_name] <- data[, term_name]
lpar[[new_term_name]] <- 0
}
}
}
}
lpar$hyper <- hyper
return(list(lpar=lpar, X=as.matrix(X[, -1]), Z=as.matrix(Z[, -1])))
}
build_design_matrix(dyad(node_1, node_2) ~ 0 + dyad_type + (1 | relatedness), df_reg)
fit_edge$num_dyads
fit_edge <- edge_model(event ~ dyad(node_1, node_2), data=df, data_type="binary", method="mcmc", mc_cores=4, verbose=TRUE)
fit_edge$num_dyads
design_matrices <- build_design_matrix(dyad(node_1, node_2) ~ 0 + dyad_type + (1 | relatedness), df_reg)
ncol(design_matrices$X)
fit_edge$node_to_idx
fit_edge$node_to_idx[df_reg$node_1]
df_reg$node_1
fit_edge$node_to_idx[df_reg$node_1]
fit_edge$node_to_idx[df_reg$node_2]
fit_edge$dyad_mapping[c(fit_edge$node_to_idx[df_reg$node_1], fit_edge$node_to_idx[df_reg$node_2])]
fit_edge$dyad_mapping[c(fit_edge$node_to_idx[df_reg$node_2], fit_edge$node_to_idx[df_reg$node_1])]
fit_edge$node_to_idx[df_reg$node_1]
fit_edge$node_to_idx[df_reg$node_2]
fit_edge$node_to_idx[df_reg$node_1]
c(fit_edge$node_to_idx[df_reg$node_1], fit_edge$node_to_idx[df_reg$node_2])
cbind(fit_edge$node_to_idx[df_reg$node_1], fit_edge$node_to_idx[df_reg$node_2])
fit_edge$dyad_mapping
fit_edge$dyad_mapping[c(fit_edge$node_to_idx[df_reg$node_1], fit_edge$node_to_idx[df_reg$node_2])]
fit_edge$node_to_idx[df_reg$node_1]
fit_edge$node_to_idx[df_reg$node_2]
fit_edge$node_to_idx[df_reg$node_1]
fit_edge$dyad_mapping[c(fit_edge$node_to_idx[df_reg$node_1], fit_edge$node_to_idx[df_reg$node_2])]
fit_edge$dyad_mapping[cbind(fit_edge$node_to_idx[df_reg$node_1], fit_edge$node_to_idx[df_reg$node_2])]
fit_edge$dyad_mapping[cbind(fit_edge$node_to_idx[df_reg$node_1], fit_edge$node_to_idx[df_reg$node_2])]
df_reg$node_1
get_all_vars(formula, df)
get_all_vars(formula, df_reg)
formula
model.frame(formula, df_reg)
all.vars(formula)
formula <- dyad(node_1, node_2) ~ 0 + dyad_type + (1 | relatedness)
all.vars(formula)
model.frame(formula, df_reg)
all.vars(formula)
all.vars(formula)[1]
df_reg[all.vars(formula)[1]]
df_reg[all.vars(formula)[2]]
obj$node_to_idx[df_reg[all.vars(formula)[1]]]
obj <- fit_edge
obj$node_to_idx[df_reg[all.vars(formula)[1]]]
formula <- dyad(node_1, node_2) ~ 0 + dyad_type + (1 | relatedness)
obj <- fit_edge
obj$node_to_idx[df_reg[all.vars(formula)[1]]]
df_reg
all.vars(formula)[1]
df_reg[all.vars(formula)[1]]
df_reg[all.vars(formula)[2]]
list(df_reg[all.vars(formula)[2]])
c(df_reg[all.vars(formula)[2]])
as.vector(df_reg[all.vars(formula)[2]])
as.vector(df_reg[all.vars(formula)[2]])
df_reg[all.vars(formula)[2]]
as.vector(df_reg[all.vars(formula)[2]])
df_reg[all.vars(formula)[2]]
df_reg[all.vars(formula)[2]][, 1]
as.vector(df_reg[all.vars(formula)[2]][, 1])
node_ids_1 <- as.vector(df_reg[all.vars(formula)[1]][, 1])
node_ids_2 <- as.vector(df_reg[all.vars(formula)[2]][, 1])
dyad_ids <- fit_edge$dyad_mapping[cbind(node_ids_1, node_ids_2)]
node_ids_1 <- as.vector(df_reg[all.vars(formula)[1]][, 1])
node_ids_2 <- as.vector(df_reg[all.vars(formula)[2]][, 1])
dyad_ids <- fit_edge$dyad_mapping[cbind(node_ids_1, node_ids_2)]
dyad_ids <- fit_edge$dyad_mapping[cbind(node_ids_1, node_ids_2)]
node_ids_2 <- as.vector(df_reg[all.vars(formula)[2]][, 1])
dyad_ids <- fit_edge$dyad_mapping[cbind(node_ids_1, node_ids_2)]
cbind(node_ids_1, node_ids_2)
node_ids_1 <- obj$node_to_idx[as.vector(df_reg[all.vars(formula)[1]][, 1])]
node_ids_2 <- obj$node_to_idx[as.vector(df_reg[all.vars(formula)[2]][, 1])]
dyad_ids <- fit_edge$dyad_mapping[cbind(node_ids_1, node_ids_2)]
dyad_ids
dim(obj$chain)
obj$chain[, dyad_ids]
dim(obj$chain[, dyad_ids])
apply(obj$chain[, dyad_ids], 2, mean)
cov(obj$chain[, dyad_ids])
model_dyadic_regression <- stan_model("inst/stan/dyadic_regression.stan")
model_dyadic_regression <- stan_model("../inst/stan/dyadic_regression.stan")
model_dyadic_regression <- stan_model("../inst/stan/dyadic_regression.stan")
model_data <- list(
N=N,
num_nodes=num_nodes,
K_fixed=K_fixed,
edge_mu=edge_mu,
edge_cov=edge_cov,
X=design_matrices$X,
node_ids_1=node_ids_1,
node_ids_2=node_ids_2
)
num_nodes <- obj$num_nodes
N <- obj$num_dyads
K_fixed <- ncol(design_matrices$X)
node_ids_1 <- obj$node_to_idx[as.vector(df_reg[all.vars(formula)[1]][, 1])]
node_ids_2 <- obj$node_to_idx[as.vector(df_reg[all.vars(formula)[2]][, 1])]
dyad_ids <- obj$dyad_mapping[cbind(node_ids_1, node_ids_2)]
edge_mu <- apply(obj$chain[, dyad_ids], 2, mean)
edge_cov <- cov(obj$chain[, dyad_ids])
model_data <- list(
N=N,
num_nodes=num_nodes,
K_fixed=K_fixed,
edge_mu=edge_mu,
edge_cov=edge_cov,
X=design_matrices$X,
node_ids_1=node_ids_1,
node_ids_2=node_ids_2
)
model_data
fit_dyad <- rstan::sampling(model_dyadic_regression, model_data, cores=4)
summary(fit_dyad)
pkgbuild::compile_dll()
roxygen2::roxygenize()
rm(list = c("build_design_matrix"))
roxygen2::roxygenize()
devtools::install()
devtools::load_all()
devtools::load_all()
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg)
devtools::load_all()
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg)
devtools::load_all()
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg)
fit_edge <- edge_model(event ~ dyad(node_1, node_2), data=df, data_type="binary", method="mcmc", mc_cores=4, verbose=TRUE)
devtools::document()
devtools::load_all()
stanmodels$duration_null
pkgbuild::compile_dll()
roxygen2::roxygenize()
devtools::install(quick=FALSE)
devtools::load_all()
devtools::load_all()
library(bisonR)
data("binary_ex1")
df <- binary_ex1
head(df)
fit_edge <- edge_model(event ~ dyad(node_1, node_2), data=df, data_type="binary", method="mcmc", mc_cores=4, verbose=TRUE)
plot_trace(fit_edge)
summary(fit_edge)
plot_network(fit_edge, lwd=2)
library(bisonR)
library(dplyr)
data("binary_ex1")
df <- binary_ex1
head(df)
df_reg <- df %>%
mutate(dyad_type=as.factor(paste(type_1, type_2, sep="-"))) %>%
distinct(node_1, node_2, dyad_type)
df_reg
df_reg$relatedness <- as.factor(sample(1:3, 28, replace=TRUE))
df_reg
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg)
devtools::load_all()
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg)
library(bisonR)
library(bisonR)
library(dplyr)
data("binary_ex1")
df <- binary_ex1
head(df)
df_reg <- df %>%
mutate(dyad_type=as.factor(paste(type_1, type_2, sep="-"))) %>%
distinct(node_1, node_2, dyad_type)
df_reg
df_reg$relatedness <- as.factor(sample(1:3, 28, replace=TRUE))
df_reg
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg)
devtools::document()
devtools::load_all()
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg)
fit_dyad
summary(fit_dyad)
library(bisonR)
library(bisonR)
library(dplyr)
data("binary_ex1")
df <- binary_ex1
head(df)
df_reg <- df %>%
mutate(dyad_type=as.factor(paste(type_1, type_2, sep="-"))) %>%
distinct(node_1, node_2, dyad_type)
df_reg
df_reg$relatedness <- as.factor(sample(1:3, 28, replace=TRUE))
df_reg
devtools::load_all()
devtools::load_all()
df_reg <- df %>%
mutate(dyad_type=as.factor(paste(type_1, type_2, sep="-"))) %>%
distinct(node_1, node_2, dyad_type)
df_reg
df_reg$relatedness <- as.factor(sample(1:3, 28, replace=TRUE))
df_reg
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg)
fit_dyad
as.integer(0)
as.integer(FALSE)
as.integer(TRUE)
devtools::load_all()
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg, mm=FALSE)
fit_dyad
devtools::load_all()
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg, mm=FALSE)
fit_dyad
library(bisonR)
library(bisonR)
library(dplyr)
fit_dyad <- dyadic_regression(dyad(node_1, node_2) ~ dyad_type, fit_edge, df_reg, mm=FALSE)
fit_dyad
